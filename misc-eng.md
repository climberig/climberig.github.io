---
layout: page
title: Misc Eng
permalink: /misc-eng
---

**What's the hardest problem in software?**

P versus NP? I don't think so. In my opinion, it is finding **meaning and motivation** (M&M). I believe we could have cured cancer, traveled to space, eradicated
poverty and... solved P versus NP had we solved the M&M. Is it possible to solve it? I wish I knew. So far, I've only managed to mitigate it.

**What do you think about interviews?**

Let's not kid ourselves, an interview is largely a lottery. I can ace all your questions but I am so demotivated and washed out, I'll never really 
help you. I'll do the minimum amount of work required and go home. Or maybe I fail the interview miserably, but when given a chance, I will rise 
to the challenge and be your best employee. I can also be too nervous and fail even if I knew how to solve a problem or perhaps I can provide a brilliant
solution but only because I just read about it. If you are trying to determine if I am a good cultural fit, then you are out of luck as well. We are engineers,
not psychologist. Can professional psychologists even do it in 45 minutes? Can anyone?

**How would you do the interview then?**

I would ask an engineer to show me his code, in his favourite environment (OS, IDE, editor). Does he know how to use his tools? Is he passionate about
his code? How does he work with it? Can he run his tests? Maybe he can teach me something. Maybe he can also look at my code and tell me something
I can improve, maybe some useful refactoring. Maybe there is a bug in my code? How would he fix it? What is his favourite command line command? 
What is his favourite bug? How did he fix it? I also think the interviewee should interview his interviewers. It should be more bilateral, we both need
each other. Maybe when I look at your code, I would not want to work for you. We'll save each other a lot of time.

**How do you define a great programmer?**

A great programmer writes correct and efficient programs in timely manner.

**What's a single most important quality of a programmer?**

I think, it is the ability to work hard (not to be confused with being busy). What is hard work? It is not easy to define it but let me give you an example.
Turn off your email, chat, phone, and any other notifications, put your IDE in full screen mode and start writing code. Don't rush it, try to stay focused. Pay attention.
Why are you creating that "to do"? You are taking a short-cut, do you think someone else will fix it for you? You don't have time now but you'll have it in the future?
The best time to address it is right now, when you have the context in your head.<br/>
Why are you debugging your own code? Maybe you should make it more readable, or add some logging? Debugging is a symptom of a deeper underlying problem. Take time and fix it. Right now.<br/>
Why are you copy-pasting that method? Maybe it's time to refactor and reuse it? Oh, you did not write it. It does not matter. Just do it. I'll do it for you next time.<br/>
You see some dead code? Delete it. It might be useful in the future. If you can predict the future, go work on Wall Street. Meanwhile, delete the dead code and move on. It is still in the version
control.<br/>
Your IDE/compiler/interpreter gives you warnings? Address them. If they are useless, disable them, otherwise, fix them. Right now.<br/>
Get tired/bored? Don't check your facebook, email, chat. Take a short walk, have a snack, stretch. And do it all over again. If you can do the above exercise for a couple hours, congratulate yourself.
You worked hard today.

**But how can I focus for so many hours if I have meetings?**

Schedule your meetings wisely, make sure they don't disrupt your ability to work hard. If your meetings are useless, **speak up**. If you don't have the courage to do so, then maybe you deserve
to be in that meeting. Or maybe you actually like it.

**Is there anything you wish programmers did more often?**

I wish we thought about complexity more. We keep introducing new frameworks, libraries, use cases while not paying enough attention to the complexity they bring. Maybe you can validate email without using
that buggy library? You'll finally learn regular expressions. You have to put multiple if/else statements throughout your code to implement the new use case. It's time to step back and think. Maybe 
the easiest way to solve it is not the right way? Maybe it is time to refactor the code. Just because you can put a couple if/else's in two minutes doesn't make you a good or efficient programmer. 

**What do you think about coding styles?**

I like code bases with different code styles. If I see some good ideas and tricks, I change my style accordingly. I don't think it's a good idea to force everyone to use a single style. Some people 
think that different styles make code harder to read and understand. I don't think so. Bad names, verbose methods, unused code, outdated documentation, inconsistent formatting - this is what makes it harder. 
A single style won't help with that.  